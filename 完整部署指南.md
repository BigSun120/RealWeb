# 🚀 Ubuntu 21.04 完整部署指南

## 📋 系统要求
- Ubuntu 22.04 x64 (推荐LTS版本) 
- 2GB+ 内存
- 20GB+ 硬盘空间
- 公网IP和域名

## 🔧 第一步：系统初始化

### 1.1 更新系统
```bash
# 更新软件包列表 ok
sudo apt update && sudo apt upgrade -y 

# 安装基础工具 ok
sudo apt install -y curl wget git vim htop unzip ca-certificates gnupg lsb-release software-properties-common

# 验证系统版本 ok
lsb_release -a
```

### 1.2 配置时区
```bash
# 设置时区为中国
sudo timedatectl set-timezone Asia/Shanghai

# 验证时间
date
```

### 1.3 配置防火墙
```bash
# 启用UFW防火墙 ok
sudo ufw --force enable
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 开放必要端口 ok
sudo ufw allow ssh
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS
sudo ufw allow 25/tcp    # SMTP
sudo ufw allow 2500/tcp  # Inbucket SMTP

# 查看防火墙状态
sudo ufw status
```

## 🐳 第二步：安装Docker

### 2.1 安装Docker
```bash
# 卸载旧版本（如果有）
sudo apt remove -y docker docker-engine docker.io containerd runc

# 添加Docker官方GPG密钥 ok
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

# 添加Docker仓库 ok
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

# 更新包列表并安装Docker ok
sudo apt update
sudo apt install -y docker-ce docker-ce-cli containerd.io

# 启动Docker服务 ok
sudo systemctl start docker
sudo systemctl enable docker

# 将当前用户添加到docker组
sudo usermod -aG docker $USER

# 重新登录以使组权限生效
newgrp docker

# 验证Docker安装 ok
docker --version
docker run hello-world
```

### 2.2 安装Docker Compose
```bash
# 下载Docker Compose ok
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

# 添加执行权限
sudo chmod +x /usr/local/bin/docker-compose

# 验证安装 ok
docker-compose --version
```

### 2.3 配置Docker镜像加速（解决HTTPS下载问题）
```bash
# 创建Docker配置目录
sudo mkdir -p /etc/docker

# 配置镜像加速器
sudo tee /etc/docker/daemon.json <<EOF
{
  "registry-mirrors": [
    "https://docker.m.daocloud.io",
    "https://dockerproxy.com",
    "https://mirror.ccs.tencentyun.com"
  ],
  "insecure-registries": [],
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
EOF

# 重启Docker服务
sudo systemctl daemon-reload
sudo systemctl restart docker

# 验证配置
docker info | grep -A5 "Registry Mirrors"
```

## 🌐 第三步：域名和SSL配置

### 3.1 安装Certbot ok
```bash
# 安装Certbot
sudo apt install -y certbot

# 验证安装
certbot --version
```

### 3.2 获取SSL证书
```bash
# 替换 your-domain.com 为您的实际域名 ok
DOMAIN="godaug.fun"

# 获取SSL证书 ✅ 已完成
# 注意：如果80端口被占用，需要先停止相关服务（如nginx）
sudo systemctl stop nginx  # 临时停止nginx
sudo certbot certonly --standalone -d $DOMAIN -d www.$DOMAIN
sudo systemctl start nginx  # 重新启动nginx

# 证书文件位置：
# 证书文件: /etc/letsencrypt/live/godaug.fun/fullchain.pem
# 私钥文件: /etc/letsencrypt/live/godaug.fun/privkey.pemprivkey.pem
# - 过期时间: 2025-11-17（自动续期已设置）

# 验证证书
sudo ls -la /etc/letsencrypt/live/$DOMAIN/
```

## 📁 第四步：项目部署

### 4.1 创建项目目录 ok
```bash
# 创建项目目录
mkdir -p ~/temp-email-system
cd ~/temp-email-system

# 创建必要的子目录
mkdir -p ssl logs nginx backend frontend
```

### 4.2 复制SSL证书 ok
```bash
# 复制证书文件到项目目录
sudo cp /etc/letsencrypt/live/$DOMAIN/fullchain.pem ssl/
sudo cp /etc/letsencrypt/live/$DOMAIN/privkey.pem ssl/
sudo chown -R $USER:$USER ssl/

# 验证证书文件 ok
ls -la ssl/
```

### 4.3 创建环境配置文件 ok
```bash
# 创建生产环境配置
cat > .env.prod << EOF
NODE_ENV=production
DOMAIN=$DOMAIN
SMTP_DOMAINS=$DOMAIN,localhost,test.local
PORT=8000
EOF
```

## 🔧 第五步：创建配置文件

### 5.1 创建Docker Compose配置 
```bash
cat > docker-compose.prod.yml << 'EOF'
version: '3.8'

services:
  # 前端服务
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./frontend/nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - backend
    restart: unless-stopped
    networks:
      - app-network

  # 后端服务
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - NODE_ENV=production
      - PORT=8000
      - INBUCKET_API=http://inbucket:9000/api/v1
    depends_on:
      - inbucket
    restart: unless-stopped
    networks:
      - app-network
    volumes:
      - ./logs:/app/logs

  # 邮件服务
  inbucket:
    image: docker.m.daocloud.io/inbucket/inbucket:latest
    ports:
      - "9000:9000"  # Web界面
      - "2500:2500"  # SMTP
      - "1100:1100"  # POP3
    environment:
      - INBUCKET_SMTP_DOMAIN=your-domain.com,localhost,test.local
      - INBUCKET_SMTP_ADDR=0.0.0.0:2500
      - INBUCKET_WEB_ADDR=0.0.0.0:9000
      - INBUCKET_POP3_ADDR=0.0.0.0:1100
      - INBUCKET_WEB_CORSORIGIN=https://your-domain.com,http://localhost:3000
      - INBUCKET_STORAGE_TYPE=file
      - INBUCKET_STORAGE_PARAMS=/data
    volumes:
      - inbucket-data:/data
    restart: unless-stopped
    networks:
      - app-network

  # Redis缓存
  redis:
    image: docker.m.daocloud.io/library/redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    restart: unless-stopped
    networks:
      - app-network
    command: redis-server --appendonly yes

volumes:
  inbucket-data:
  redis-data:

networks:
  app-network:
    driver: bridge
EOF
```

### 5.2 替换域名配置 ok
```bash
# 替换配置文件中的域名 
sed -i "s/your-domain.com/$DOMAIN/g" docker-compose.prod.yml

### 5.3 创建前端Nginx配置 ok
```bash
mkdir -p frontend
cat > frontend/nginx.conf << 'EOF'
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log;

    # 基本设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;

    # 上游后端服务
    upstream backend {
        server backend:8000;
    }

    # HTTP服务器（重定向到HTTPS）
    server {
        listen 80;
        server_name your-domain.com www.your-domain.com;

        # Let's Encrypt验证
        location /.well-known/acme-challenge/ {
            root /var/www/certbot;
        }

        # 重定向到HTTPS
        location / {
            return 301 https://$server_name$request_uri;
        }
    }

    # HTTPS服务器
    server {
        listen 443 ssl http2;
        server_name your-domain.com www.your-domain.com;

        # SSL证书配置
        ssl_certificate /etc/nginx/ssl/fullchain.pem;
        ssl_certificate_key /etc/nginx/ssl/privkey.pem;

        # SSL安全配置
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # 安全头
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

        # 前端静态文件
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;

            # 缓存设置
            location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
        }

        # API代理
        location /api/ {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;

            # 超时设置
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # 临时邮箱服务
        location /temp-email {
            proxy_pass http://backend/temp-email;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 健康检查
        location /health {
            proxy_pass http://backend/health;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # 静态资源
        location /uploads/ {
            alias /app/uploads/;
            expires 30d;
            add_header Cache-Control "public, immutable";
        }
    }
}
EOF

# 替换nginx配置中的域名
sed -i "s/your-domain.com/$DOMAIN/g" frontend/nginx.conf
```

### 5.4 创建前端Dockerfile ok
```bash
cat > frontend/Dockerfile.prod << 'EOF'
# 构建阶段
FROM node:18-alpine AS builder

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 构建生产版本
RUN npm run build

# 生产阶段
FROM nginx:alpine

# 复制构建结果
COPY --from=builder /app/dist /usr/share/nginx/html

# 复制nginx配置
COPY nginx.conf /etc/nginx/nginx.conf

# 创建必要目录
RUN mkdir -p /var/www/certbot

# 暴露端口
EXPOSE 80 443

# 启动nginx
CMD ["nginx", "-g", "daemon off;"]
EOF
```

### 5.5 创建后端Dockerfile ok
```bash
cat > backend/Dockerfile << 'EOF'
FROM node:18-alpine

WORKDIR /app

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 创建必要目录
RUN mkdir -p logs uploads

# 暴露端口
EXPOSE 8000

# 启动应用
CMD ["npm", "start"]
EOF
```

## 🚀 第六步：部署应用

### 6.1 预拉取Docker镜像（解决HTTPS下载问题）  ok
```bash
# 拉取基础镜像
docker pull docker.m.daocloud.io/library/node:18-alpine            # ok
docker pull docker.m.daocloud.io/library/nginx:alpine             # ok
docker pull docker.m.daocloud.io/library/redis:7-alpine          # ok
docker pull docker.m.daocloud.io/inbucket/inbucket:latest      # ok

# 给镜像打标签（让Docker Compose能找到） ok
docker tag docker.m.daocloud.io/library/node:18-alpine node:18-alpine
docker tag docker.m.daocloud.io/library/nginx:alpine nginx:alpine
docker tag docker.m.daocloud.io/library/redis:7-alpine redis:7-alpine
docker tag docker.m.daocloud.io/inbucket/inbucket:latest inbucket/inbucket:latest

# 验证镜像
docker images
```

### 6.2 创建应用代码（示例） 使用项目代码
```bash
# 创建简单的后端应用
cat > backend/package.json << 'EOF'
{
  "name": "temp-email-backend",
  "version": "1.0.0",
  "main": "app.js",
  "scripts": {
    "start": "node app.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "axios": "^1.4.0"
  }
}
EOF

cat > backend/app.js << 'EOF'
const express = require('express');
const cors = require('cors');
const app = express();
const PORT = process.env.PORT || 8000;

app.use(cors());
app.use(express.json());

// 健康检查
app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
});

// 临时邮箱API
app.get('/temp-email', (req, res) => {
    res.json({ message: '临时邮箱服务正常运行' });
});

app.listen(PORT, '0.0.0.0', () => {
    console.log(`服务器运行在端口 ${PORT}`);
});
EOF

# 创建简单的前端应用 使用项目代码
cat > frontend/package.json << 'EOF'
{
  "name": "temp-email-frontend",
  "version": "1.0.0",
  "scripts": {
    "build": "mkdir -p dist && echo '<h1>临时邮箱系统</h1><p>服务正常运行</p>' > dist/index.html"
  }
}
EOF
```

### 6.3 启动服务
```bash
# 构建并启动所有服务
docker-compose -f docker-compose.prod.yml up -d --build

# 查看服务状态
docker-compose -f docker-compose.prod.yml ps

# 查看日志
docker-compose -f docker-compose.prod.yml logs -f
```

## 🔍 第七步：验证部署

### 7.1 检查服务状态
```bash
# 检查所有容器状态
docker ps

# 检查端口监听
sudo netstat -tlnp | grep -E ':(80|443|8000|9000|2500)'

# 测试HTTP重定向
curl -I http://$DOMAIN

# 测试HTTPS访问
curl -I https://$DOMAIN

# 测试API
curl https://$DOMAIN/health
```

### 7.2 设置SSL证书自动续期
```bash
# 添加自动续期任务
echo "0 3 1 * * certbot renew --quiet && docker-compose -f ~/temp-email-system/docker-compose.prod.yml restart frontend" | crontab -

# 查看定时任务
crontab -l
```

## 🎉 完成！

现在您的服务应该可以通过以下地址访问：

- **主站**: https://your-domain.com
- **API**: https://your-domain.com/api/
- **健康检查**: https://your-domain.com/health
- **邮件管理**: http://your-domain.com:9000

## 🛠️ 常用管理命令

```bash
# 查看服务状态
docker-compose -f docker-compose.prod.yml ps

# 重启服务
docker-compose -f docker-compose.prod.yml restart

# 查看日志
docker-compose -f docker-compose.prod.yml logs -f [service_name]

# 停止服务
docker-compose -f docker-compose.prod.yml down

# 更新服务
docker-compose -f docker-compose.prod.yml pull
docker-compose -f docker-compose.prod.yml up -d --build
```

这个部署指南解决了所有HTTPS下载问题，使用了国内镜像源，并且配置了完整的SSL支持！
```
